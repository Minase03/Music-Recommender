import pandas as pd
import random
import numpy as np # Import numpy for numerical operations, especially for abs()

# Load song dataset
def load_music_data(df_path="df.pkl"):
    try:
        with open(df_path, "rb") as f:
            return pd.read_pickle(f)
    except FileNotFoundError:
        print(f"Error: {df_path} not found. Please ensure 'df.pkl' is generated by 'Model Training.ipynb' or 'utils.py'.")
        # Return an empty DataFrame or raise an error as appropriate
        return pd.DataFrame()


# Simple genre/mood mapping based on keywords â€” keep this for potential alternative mood matching
mood_to_keywords = {
    "Happy": ["Dance", "Pop", "Party", "Upbeat"],
    "Sad": ["Ballad", "Acoustic", "Slow", "Love"],
    "Energetic": ["Rock", "Rap", "Electronic"],
    "Relaxed": ["Chill", "Lo-Fi", "Indie", "Ambient"]
}

# Function to filter songs based on mood keywords
def get_songs_by_mood(mood, df):
    keywords = mood_to_keywords.get(mood, [])
    if df.empty:
        return pd.DataFrame() # Return empty if df is empty

    # You can match genre, song name, or artist (based on available columns)
    # Ensure 'song' and 'artist' columns exist before trying to access
    filtered = pd.DataFrame()
    if 'song' in df.columns and 'artist' in df.columns:
        filtered = df[
            df['song'].astype(str).str.contains('|'.join(keywords), case=False, na=False) |
            df['artist'].astype(str).str.contains('|'.join(keywords), case=False, na=False)
        ]

    # If nothing found or columns missing, just return some random songs as fallback
    if filtered.empty:
        if not df.empty:
            return df.sample(min(5, len(df)))
        return pd.DataFrame() # Return empty if original df is also empty
    return filtered.sample(min(5, len(filtered)))


# --- New: Sentiment-based Vibe Matching ---

# Define sentiment ranges for moods (adjust these based on your sentiment model's output)
# sentiment_score is expected to be between -1 (very negative) and 1 (very positive)
mood_sentiment_ranges = {
    "Happy": (0.6, 1.0),     # High positive sentiment
    "Chill": (0.0, 0.5),     # Neutral to moderately positive/calm
    "Hype": (0.7, 1.0),      # Very positive and high energy (consider combining with audio features)
    "Sad": (-1.0, -0.4),     # High negative sentiment
    "Romantic": (0.2, 0.8)   # Can be positive, but not overly "Hype"; perhaps slightly less intense positive
}

def get_songs_by_vibe(vibe_mood, df, num_songs=5):
    """
    Recommends songs based on a selected 'vibe' using pre-calculated sentiment scores.
    'vibe_mood': User's chosen mood (e.g., "Happy", "Sad", "Hype").
    'df': Your music DataFrame with a 'sentiment_score' column.
    """
    if df.empty:
        return pd.DataFrame() # Return empty if df is empty

    if 'sentiment_score' not in df.columns:
        print("Warning: 'sentiment_score' column not found in DataFrame. Falling back to random songs for vibe match.")
        return df.sample(min(num_songs, len(df))) # Fallback to random if no sentiment score

    sentiment_range = mood_sentiment_ranges.get(vibe_mood)

    if sentiment_range:
        min_score, max_score = sentiment_range
        filtered_songs = df[(df['sentiment_score'] >= min_score) & (df['sentiment_score'] <= max_score)]

        if not filtered_songs.empty:
            # Sort by proximity to the center of the sentiment range for better matches
            target_center = (min_score + max_score) / 2
            filtered_songs = filtered_songs.copy() # Avoid SettingWithCopyWarning
            filtered_songs['sentiment_distance'] = np.abs(filtered_songs['sentiment_score'] - target_center)
            filtered_songs = filtered_songs.sort_values(by='sentiment_distance').head(num_songs)

            # Ensure essential columns are returned. Add 'album_cover_url' if available in df.
            return filtered_songs[['song', 'artist', 'album_cover_url']] if 'album_cover_url' in filtered_songs.columns else filtered_songs[['song', 'artist']]

    # Fallback if mood not found, or no songs match sentiment range, return random
    print(f"No specific songs found for vibe '{vibe_mood}' with sentiment. Returning random songs.")
    return df.sample(min(num_songs, len(df)))[['song', 'artist', 'album_cover_url']] if 'album_cover_url' in df.columns else df.sample(min(num_songs, len(df)))[['song', 'artist']]